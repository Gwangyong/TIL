# 2025.07.01(화) - 장바구니 셀 동적 높이 조절 + 스크롤 처리
> **Status**: 🎯 **블로그 발행**<br>**Blog**: [장바구니 셀 동적 높이 조절 + 스크롤 문제 해결](https://jud00.tistory.com/entry/%ED%8A%B8%EB%9F%AC%EB%B8%94-%EC%8A%88%ED%8C%85-%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88-%EC%85%80-%EB%8F%99%EC%A0%81-%EB%86%92%EC%9D%B4-%EC%A1%B0%EC%A0%88-%EC%8A%A4%ED%81%AC%EB%A1%A4)

## 1. 작은 화면에서 장바구니 화면 접근 불가능한 문제

팀 프로젝트에서 장바구니 역할을 맡아 구현했는데, 초기 구조는 상품 목록 영역(`ProductPageView`)과 장바구니 영역(`cartView`)이 **각각 개별 View로 분리된 구조**였다.

큰 화면에서는 문제가 없었지만, 작은 화면(iPhone SE 등)에서는 상품 목록 영역이 커질수록 **장바구니 영역 자체가 화면 아래로 밀려 거의 보이지 않는 문제가 발생했다.** 

<img width="750" height="1334" alt="Image" src="https://github.com/user-attachments/assets/1fea7f84-539d-4022-bd96-d92e4fb3f114" />

이로인해 장바구니 View 자체가 화면에 들어오지도 않아 접근할 수 없고, 결과적으로 작은 화면에서는 장바구니 + 하단 버튼이 사실상 가려지는 UX 문제가 생겼다.

## 2. 해결 방향: 화면 전체를 하나의 스크롤로 만들기

이 문제를 해결하려면 특정 영역만 스크롤되는 구조가 아니라, **상품 목록 → 장바구니 → 하단 버튼까지 한 흐름으로 스크롤 접근이 가능**하면 될거라 생각했다.

그래서 아래처럼 화면 구조를 변경했다.

- ScrollView 안에
- StackView로 `ProductPageView`와 `CartView`를 세로로 쌓는 구조.

이러면 작은 화면에서도 사용자가 스크롤을 통해 장바구니 영역까지 내려갈 수 있었다.

## 3. 추가로 생긴 고민

이렇게 해결되었나 했지만, 화면 전체가 하나의 ScrollView 구조가 되면서 `cartView`내부의 TableView까지 동시에 스크롤이 가능해 **전체 스크롤 + 장바구니 내부 스크롤이 함께 동작**하는 구조가 되었다.

이 경우 스크롤 방향이 겹치고, 스크롤할때 영역 충돌이 생길 가능성이 높아서 **장바구니 자체 스크롤을 하지 않도록 하는게 더 낫다고 판단했다.**

따라서 **장바구니 영역은 자체적으로 스크롤하지 않고, 화면 전체 스크롤만 사용**하도록 했다.

```swift
tableView.isScrollEnabled = false
```

## 4. 새로 생긴 문제.. 스크롤을 막으면 “높이”를 직접 책임져야한다.

TableView 스크롤을 끄면, 이제 장바구니 셀들은 내부에서 스크롤로 보이는게 아니라 **모두 “한 번에 펼쳐져서” 보여지는 구조**가 된다.

즉, 셀이 늘어나면

- 장바구니 View의 높이가 같이 늘어나야하고
- 그만큼 바깥 ScrollView의 스크롤 범위도 자연스럽게 늘어나야 한다.

그래서 결과적으로 **셀 개수 기반으로 `CartView`높이를 동적으로 계산해서 제약을 갱신시키는 방식**이 필요했다.

## 5. 구현!

### 5-1. CartView에 높이 업데이트 메서드 추가

---

CartView 내에서 TableView를 감싸고 있는 컨테이너(`tableContainerView`)의 높이를 바꾸는 `updateHeight`메서드를 만들었다. 높이 값을 외부에서 받아 제약을 갱신하는 역할을한다.

SnapKit에 있는 `remakeConstraints`를 사용하여 제약 조건을 업데이트 해주는 방식을 사용했다.

```swift
// CartView.swift
func updateHeight(_ height: CGFloat) { 
  tableContainerView.snp.remakeConstraints {
    $0.top.equalTo(safeAreaLayoutGuide)
    $0.leading.trailing.equalToSuperview().inset(16)
    $0.height.equalTo(height) // 동적으로 변경
  }
}
```

### 5-2. 중간 뷰(**ScrollProductCartView)가 중간 조정자 역할**

---

외부(ViewController)에서 받은 height를 CartView에도 전달하고, 자신의 제약도 동적으로 변경시켰다.

```swift
// ScrollProductCartView.swift
func updateHeight(_ height: CGFloat) {
  cartView.updateHeight(height) // CartView에도 전달
  
  cartView.snp.remakeConstraints {
    $0.top.equalTo(productPageView.snp.bottom)
    $0.leading.trailing.equalToSuperview()
    $0.height.equalTo(height) // 동적으로 변경
  }
}
```

### 5-3. ViewController에서 높이 계산 규칙을 한 군데로 조정

---

셀 하나의 높이는 버튼을 누를 때 HIG에서 권장하는 최소 값인 44x44를 참고해 44pt로 고정했다.

최소 4개의 셀 공간을 확보하여, “장바구니가 비어있습니다.” 문구를 포함하기 위해서 44 * 4의 값을 초기값으로 주었고, 이후에 4개 이상 셀이 늘어나면 더 늘어나도록 `max(rowHeight * 4, rowHeight * count)` 방식으로 총 높이를 계산했다.( `max(44 * 4, 44 * count)`  이런 느낌)

```swift
// ViewController.swift
func updateCartView() {
	let rowHeight: CGFloat = 44
	let totalHeight = max(rowHeight * 4, rowHeight * CGFloat(cartItems.count))
	scrollProductCartView.updateHeight(totalHeight)
	
	...
	...
}
```

그리고 셀이 추가/삭제될 때마다 `updateCartView()`가 호출되도록 연결했다.

## 결과

- 작은 화면에서도 장바구니 영역이 화면 아래로 밀려 사라지지 않음
- 스크롤 동작이 “한 개(전체)”로 통일되서 사용성이 좋아짐
- 셀 개수 변화에 따라 장바구니 높이 및 전체 스크롤 범위가 자연스럽게 확장됨

![Image](https://github.com/user-attachments/assets/579df412-52f1-4a97-8dc9-9ca27d08bad8)