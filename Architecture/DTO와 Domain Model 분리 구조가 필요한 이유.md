# DTO와 Domain Model 분리 구조가 필요한 이유
> **Status**: ✅ **학습 완료**<br>**Blog**: 

## 1. 공부하게된 계기?

같이 공부하는 분들을 통해 `DTO`라는 개념을 들었었는데, **DTO / Domain Model 구조**라는게 있다는걸 최근 알게되었다.

생각난김에 찾아보니 역할이 `CodingKeys`와 비슷해 보였고, 단순 키 매핑이랑은 어떻게 다른지 등 비교하면서 공부하게 되었다.

## 2. CodingKeys의 역할과 한계

**`CodingKeys`는 JSON의 key 이름과 Swift 프로퍼티 이름을 매핑해주는 기능이다.**

예를 들자면, `user_name` → `userName` 이런식으로 `snake_case`로 되어있는 프로퍼티 이름을 `camelCase`로 매핑해줄 수 있다.

하지만 아래와 같은 **한계**가있다.

- 타입 변환 불가능 (`”1000”` → `Int`)
- 구조 평탄화 불가능 (깊은 JSON 구조를 단순 구조로 바꾸기 어려움)
    - `data.user_info.basic.id` → `id` 이런걸 “구조 평탄화”라고 한다.
- 여러 API 구조 대응이 어려움
- 의미 변환 불가능 (`Y/N` → Bool의 `true/false` 등)

즉, `CodingKeys`는 **“이름 문제”만 해결할 수 있고, 서버 구조/이름/변경 문제까지는 해결할 수 없다.**

## 3. DTO / Domain Model 구조

DTO / Domain 구조는 모델을 두 개로 나눈다.

- **DTO (Data Transfer Object)**
    - 서버 JSON 구조를 그대로 반영한 모델
    - 서버 key 이름 그대로 사용하거나, 최소한의 매핑만 수행
    - 디코딩 및 전송 전용
- **Domain Model**
    - 앱 내부에서 실제로 사용하는 모델
    - camelCase, 의미 있는 이름, 비즈니스 규칙 반영
    - 앱 로직과 화면에서 사용하는 핵심 모델

그리고 반드시, `DTO` → `Domain` 변환 메서드가 필요하다. (`toDomain()`, `init(dto:)` 등)

DTO를 Domain Model로 변환시켜야 실제 앱에서 원하는대로 사용이 가능하기 때문이다.

## 4. DTO / Domain Model을 사용하는 이유

### 4-1. 필드 이름이 서버 취향에 종속되는 문제

---

실제 서버는 항상 좋은 상태가 아닐 수 있다. 

예를 들자면 필드 이름이

- `user_nm`
- `yn_active`
- `user_age_val`

이런식으로 “약어 사용”, “의미 어려움”, “boolean이 Y/N의 형태”일 수 있다.

이 구조를 그대로 앱의 Model에서 사용하게되면, 앱 코드 전체가 서버 취향에 따라가며, 쓸 때마다 의미 해석도 해야하고, 유지보수하는데 비용이 증가하게된다.

### 4-2. 응답 구조가 깊어지는 문제

---

예를 들어서 서버 JSON이 아래와 같다고 치자

```json
{
	"data": {
		"result": {
			"user_info": {
				"basic": {
					"id": 12,
					"name": "Mori"
				}
			}
		}
	}
}
```

위의 JSON 데이터 중 내가 앱에서 필요한건 `id`값 하나 뿐인데 값을 사용하기 위해서

```json
data.result.user_info.basic.id
```

이 구조를 그대로 사용하게 된다면 **코드가 매우 복잡**해지게 된다.

하지만, `DTO` → `Domain` 변환을 사용한다면, 

- 깊은 구조는 `toDomain()` 등의 메서드에서 한 번만 처리
- `Domain`에서는 `user.id` 처럼 단순하게 사용이 가능

이처럼 앱 내에서 사용할때 편하게 “구조 평탄화”를 할 수 있다.

### 4-3. 같은 개념인데 API마다 이름이 다른 문제

---

찾다보니 실제 서버에서 같은 의미의 값이 API마다 다르게 내려오는 경우가 있다고한다.

ex)

- id
- user_id
- uid
- uuid

이렇게 말이다.

`CodingKeys`로 매핑할 수 있지만, API마다 다른 모델이 생기거나 추후에 모델 구조와 유지보수가 점점 복잡해진다고한다.

하지만, `DTO / Domain`을 분리하면, 서버 스펙인 `DTO` 계층에서만 처리하고, `Domain`에서는 `id` 하나로 통일된 모델을 사용할 수 있게된다.

## 5. DTO / Domain 분리의 핵심 장점

### 5-1. 서버 구조를 앱 내부에서 숨길 수 있다.

---

`DTO`와 `toDomain()`같은 변환 코드에서는 서버 구조가 보이지만, `Domain` 이후 코드에서는 서버 key, 구조, 표현 방식을 전혀 모르게 할 수 있다.

결과적으로, 앱 내부 코드는 서버 스펙과 완전히 분리되며, iOS 파트는 서버 구조를 더 이상 신경 쓸 필요가 없다.

### 5-2. 서버 변경 시 영향 범위 최소화

---

서버 응답 구조는 개발 도중이나 운영 도중에 변경될 수 있다.

예를 들어서 `user_nm` → `user_name`처럼 `key` 이름만 변경되는 경우라면, `CodingKeys` 수정만으로 대응이 가능하다.

다만, 위에서 말한대로 `CodingKeys`의 한계가 있기에, `DTO`를 사용하지 않고 `Domain` 모델이 곧 서버 디코딩 모델인 구조라면, 해당 Model을 사용하는 로직, ViewModel, View 코드까지 수정해야하는 경우가 생길 수 있다.

즉, 서버 변경 하나 때문에 **모델 수정** → **사용하는 모든 코드 수정으로 수정해야할 코드가 크게 늘어나게 된다.** 

반면에 `DTO / Domain` 구조를 사용하게 된다면, 

- 서버 변경은 **`DTO` 모델과 `DTO` → `Domain` 변환 코드**에서만 처리
- Domain / ViewModel / View 코드는 **그대로 유지**

결과적으로, **서버 변경이 생기더라도 수정 범위를 DTO 계층으로 최소화할 수 있으며, 나머지 코드들은 서버 변경 사실조차 신경쓰지 않고 유지**할 수 있다.

### 5-3. 구조/의미/표현을 앱에 맞게 사용 가능

---

- 깊은 구조 → 평탄 구조
- 약어 → 의미를 알기 쉬운 이름
- 문자열 → 숫자 / Bool

이처럼 DTO / Domain 구조를 사용하면 2번에서 말한 CodingKeys의 한계를 보완할 수 있으며, 앱 코드 가독성 향상, 로직 단순화, 유지보수 안정성 증가 등의 장점이 있다.

## 6. 정리

> **CodingKeys:**
> 
- CodingKeys는 JSON key 이름 매핑만 해결한다
- 서버 구조, 의미, 변경, 복잡도 문제까지 해결하지는 못한다.

> **DTO / Domain 분리:**
> 
- 깊은 구조를 평탄화
- 서버 구조를 앱 내부에서 숨김 (추상화)
- 구조와 의미를 앱에 맞게 정리 가능
- 서버 변경 영향 범위를 최소화 가능