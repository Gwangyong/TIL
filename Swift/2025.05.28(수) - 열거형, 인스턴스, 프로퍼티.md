# 2025.05.28(수) - 열거형, 인스턴스, 프로퍼티
> **Status**: 🎯 **블로그 발행**<br>**Blog**: [Convenience init과 프로퍼티](https://jud00.tistory.com/entry/0528-%EC%88%98-Convenience-init%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0)

- `enum` , `class` , `struct` 은 모두 데이터 타입으로 사용할 수 있으며, 이름으 대문자로 시작하는 Camel Case로 만든다.
- 지금까지 사용한 Int, String도 사실 `struct`로 만들어진 데이터 타입이다.

## 열거형, Enum

- enum은 관련된 값을 그룹화할 수 있으며, 그룹화된 값은 enum의 코드블럭 내에서 case를 사용하여 정의할 수 있다.
- enum은 데이터 타입으로 사용이 가능하다
- 타입 안전성을 보장하고, 의도를 명확하게 파악할 수 있다.

```swift
// 기본
enum Season {
	case pring
	case summer
	case autume
	case winter
}

// 기본 접근 방법
Season.spring
Season.summer

// 데이터 타입처럼 저장
var season: Season = .spring
var summer = Season.summer
```

### enum Associated Values (연관 값)
---

연관 값은 추가적인 정보를 연관시켜서 저장할 수 있는 기능이다. 각 case와 함께 타입을 지정하여 선언하면 연관값을 가지고 사용할 수 있다.

```swift
// 택배 배송 상태를 관리하는 열거형
enum DeliveryStatus {
	case ordered // 주문함
	case shipping(trackingNumber: String) // 배달 중
	case delevereCompleted(date: String) // 배달 완료
}
```

```swift
let status = DeliveryStatus.shipping(trackingNumber: "test")

print(status) // shipping(trackingNumber: "test")

swithch status {
case .ordered: // .ordered 상태일 때 아래의 코드 실행
	print("주문이 완료되었습니다.")
case .shipping(let trackingNumber): // .shipping 상태일 때 아래의 코드 실행
	print("배송중입니다. 송장 번호: \(trackingNumber)")
case .delevereCompleted(let date): //.delevereCompleted 상태일 때 아래의 코드 실행
	print("배송 완료되었습니다. 배송일: \(date)")
}

```

### enum Raw Values (원시 값)
---

- enum의 각 케이스에 고유한 값(정수, 문자열 등)을 할당한 것이다.
- enum 이름 뒤에 콜론(:)을 작성한 후 타입을 명시해주어야하며, case 뒤에 =을 사용해 원시값을 정해줄 수 있다.
- rawValue 속성을 통해서 원시 값을 가져올 수 있고, 매칭되는 rawValue가 없을 수 있기 때문에 Optional의 값으로 나오게된다.

> 문자형의 Raw Value
> 

```swift
enum Direction: String {
    case north = "북쪽"
    case east = "동쪽"
    case south = "남쪽"
    case west // 값이 없다면 case 이름과 동일하게 된다. (숫자형이라면 그 전번 숫자 +1)
}

let dir = Direction.east
print(dir.rawValue) // 출력: "동쪽"

let dir2 = Direction.west
print(dir2.rawValue) // 출력: "west"

// rawValue를 가지고 Direction 상수(변수)를 만들 수 있다.
let newDir = Direction(rawValue: "남쪽")
print(newDir) // 출력: Optional(Direction.south)

```

> 숫자형의 Raw Value
> 

```swift
enum NumberGame: Int {
    case one = 1
    case two = 2
    case three // 값을 정해주지 않아서 2다음인 3이 된다.
    case four // 값을 정해주지 않아서 4가 된다.
}

print(NumberGame.one.rawValue) // 1
print(NumberGame.two.rawValue) // 2
print(NumberGame.three.rawValue) // 3
print(NumberGame.four.rawValue) // 4

let anotherNumber = NumberGame(rawValue: 3)
print(anotherNumber) // Optional(NumberGame.three)

```

### enum 활용
---

- enum에서 함수를 정의하고 사용 가능

```swift
enum Season: String {
	case spring
	case summer
	case autumn
	case winter
	
	func weather() -> String {
		switch self {
		case .spring:
			return "따뜻해요"
		case .summer:
			return "더워요"
		case .autumn:
			return "시원해요"
		case .winter:
			return "추워요"
		}
	}
}

let season = Season.spring
print(season.weather()) // 따듯해요
```

## 인스턴스

인스턴스는 class, struct ,enum과 같은 설계도를 기반으로 실제 메모리에 생성되는 실체이다.

class, struct, enum은 설계도(붕어빵 틀)의 역할을 하고, 인스턴스는 **설계도를 보고 직접 만들어져서 메모리에 저장되어 있는 값(붕어빵)**이다.

## 편의 이니셜라이저 (Convenience initializer)

convenience init은 class에서만 사용 가능한 키워드로, 직접 초기화하는게 아닌, 다른 이니셜라이저를 호출해서 초기화하는 보조 이니셜라이저이다.

반드시 같은 클래스 내의 지정 이니셜라이저(init) 또는 상위 클래스의 지정 이니셜라이저를 호출해야한다.

주로 기본 이니셜라이저를 간단하게 호출하거나, 초기화 과정을 더 편리하게 만들고 싶을 때 사용함

```swift
class SomeClass {
	var name: String
	var age: Int
	
	// 지정 이니셜라이저
	init(name: String, age: Int) {
		self.name = name
		self.age = age
	}
	
	// 편의 이니셜라이저 (Convenience initializer)
	convenience init(name: String) {
		self.init(name: name, age: 0) // 기본 나이를 0으로 설정
	}
	
	// 또 다른 편의 이니셜라이저
	convenience init() {
		self.init(name: "Unknown", age: 0)
	}
}
```

---

## **🧱 Swift 프로퍼티(Property)**

> Swift에서 프로퍼티는 **클래스(Class), 구조체(Struct), 열거형(Enum)**
> **내부에 정의되어** 크게 4가지로 나뉘며 각각의 동작 방식과 특징이 다르다.

### **✅ 프로퍼티의 종류**

- **저장 프로퍼티 (Stored Property)**
- **연산 프로퍼티 (Computed Property)**
- **지연 저장 프로퍼티 (Lazy Stored Property)**
- **타입 프로퍼티 (Type Property)**



### **📌 1. 저장 프로퍼티 (Stored Property)**

- 실제 값을 **메모리에 저장**하는 기본적인 프로퍼티
- `var` 또는 `let`으로 선언
- `=`로 초기값을 가질 수 있음
- struct, class 에서 사용 가능 (enum에서는 불가능)
- 추가로, `lazy var`도 저장 프로퍼티 (지연 초기화일 뿐)

```swift
struct Person {
  var name: String
  let birthYear: Int
}

let user = Person(name: "Gwangyong", birthYear: 2000)
print(user.name) // Gwangyong
```

---

### **📌 2. 연산 프로퍼티 (Computed Property)**

- 실제 값을 저장하지 않고, **값을 계산해서 반환**하는 프로퍼티

> 예시
> 

```swift
// 기본 get을 생략한 형태
var fullName: String {
	firstName + lastName
}
```

또는

```swift
var score: Int {
	get {
	  // 읽을 때 실행됨
    // internalScore를 기반으로 값을 계산해서 돌려줌
		internalScore * 2
	}
	set {
	  // 쓸 때 실행됨
    // 외부에서 받은 값(newValue)을 기반으로 internalScore를 재계산해 저장함
		internalScore = newValue / 2
	}
}
```

- 내부에 **저장 공간이 없음**
- `get` → 값을 계산해서 반환
- `set` → 다른 저장 프로퍼티에 값 반영
- `let` 사용 불가능 (`var`만 사용 가능)
- struct, class, enum 모두 사용 가능

<aside>

### newValue란?

set 블록에서 프로퍼티에 새로 설정된 값을 의미하는 기본 매개변수 이름

따로 이름을 저장하지 않으면, Swift가 자동으로 `newValue` 라는 이름을 사용함

</aside>

### get과 set이 햇갈린다면?

- 정리해둔 Notion Link: [Swift get/set 문법](https://www.notion.so/Swift-get-set-2e68f738d00280dbb174d738eeaf39c2?pvs=21)

---

### **📌 3. 타입 프로퍼티 (Type Property)**

- 인스턴스가 아닌 **타입 자체에 속하는 프로퍼티**
- 모든 인스턴스가 값을 공유함
- 구조체/열거형 → **static**만 사용
- 클래스 → **static, class** 모두 사용 가능 (단, class는 오버라이드 가능한 연산 프로퍼티 전용)

```swift
struct Counter {
  static var count = 0

  static var info: String {
    return "총 \(count)회 호출됨"
  }
}

Counter.count += 1
print(Counter.info) // 총 1회 호출됨
```

```swift
class Message {
  class var greeting: String {
    return "Hello!"
  }
}

class CustomMessage: Message {
  override class var greeting: String {
    return "Hi!"
  }
}

print(Message.greeting)       // Hello!
print(CustomMessage.greeting) // Hi!
```

### **📌 3.5 프로퍼티 옵저버 (Property Observer)**

---

- 저장 프로퍼티의 값이 변경되는 것을 감시하고 있다가 코드블록을 실행할 수 있는 기능
- **상속받은 저장 프로퍼티, 상속받은 연산 프로퍼티** 에서도 사용 가능
- 저장 프로퍼티가 사용 가능한 `struct`와 `class`에서만 사용 가능
- `willSet`
    - 값이 **변경되기 직전**에 호출됨
    - 변경될 값은 기본 매개변수 `newValue`로 접근 가능
    - 별도 이름 지정 가능: `willSet(이름)` 형태로 작성
- `didSet`
    - 값이 **변경된 직후**에 호출됨
    - 이전 값은 기본 매개변수 `oldValue`로 접근 가능
    - 별도 이름 지정 가능: `didSet(이름)` 형태로 작성

> 기본 사용 예시
> 

```swift
struct Person {
    var name: String {
        willSet {
            print("Person의 name이 변경될 예정입니다. 변경될 이름은 \"\(newValue)\"입니다. (willSet 호출)")
        }
        
        didSet {
            print("Person의 name이 \"\(oldValue)\"에서 \"\(name)\"으로 변경되었습니다. (didSet 호출)")
        }
    }
}

var person = Person(name: "Mori")

person.name = "Apple"

/* 출력
 Person의 name이 변경될 예정입니다. 변경될 이름은 "Apple"입니다. (willSet 호출)
 Person의 name이 "Mori"에서 "Apple"으로 변경되었습니다. (didSet 호출)
 */
```

> `newValue`, `oldValue` 다른 이름으로 변경한 사용 예시
> 

```swift
struct Person {
    var name: String {
        willSet(changeNewName) { // newValue -> changeNewName
            print("Person의 name이 변경될 예정입니다. 변경될 이름은 \"\(changeNewName)\"입니다. (willSet 호출)")
        }
        
        didSet(beforName) { // oldValue -> beforName
            print("Person의 name이 \"\(beforName)\"에서 \"\(name)\"으로 변경되었습니다. (didSet 호출)")
        }
    }
}

var person = Person(name: "Mori")

person.name = "Apple"
```

---

### **📌 4. 지연 저장 프로퍼티 (Lazy Stored Property)**

- 인스턴스 생성 시 초기화되지 않고, **처음 접근할 때 초기화**
- lazy 키워드를 사용 (항상 var로만 선언)
- 구조체, 클래스에서 사용 가능

```swift
// 예시 : 지하 주차장 조명
class ParkingLot {
    lazy var light: String = {
        print("💡 주차장 조명이 켜졌습니다")
        return "불 켜짐"
    }()
}

let lot = ParkingLot()
print("사람이 아직 없음")

// 누군가 들어올 때 조명이 켜짐
print(lot.light)
```

> lazy 사용 x
<img width="318" height="341" alt="Image" src="https://github.com/user-attachments/assets/272acff1-cd9d-4724-8bd5-b21513d87212" />


> lazy 사용 o
<img width="318" height="336" alt="Image" src="https://github.com/user-attachments/assets/c2f7eebf-acd9-43b2-8b2c-1bf2ff9c459b" />

### 내가 보기 쉽게 정리한 것

---

- **getter, setter / get, set (연산 프로퍼티)**
    - **실제 값을 저장하지 않고**, 계산된 값을 반환
    - get으로 값을 반환, set으로 값을 설정
    
- **static (타입 프로퍼티)**
    - 인스턴스가 아닌, “타입 자체에 속한” 프로퍼티
    - 인스턴스를 만들지 않아도, `Dog.species`로 직접 접근 가능
    - 모든 Dog 타입에서 **같은 값을 공유함**
    
    ```swift
    // 타입 프로퍼티 (Static)사용x -> (인스턴스 프로퍼티)
    struct Dog {
    	var species = "강아지"
    }
    
    let dog = Dog()
    print(dog.species) // 강아지
    
    // 타입 프로퍼티 (static)사용
    struct Dog {
    	static var species = "강아지"
    }
    
    print(Dog.specoes) // 강아지
    ```
    

- **lazy (지연 저장 프로퍼티)**
    - 말 그대로 처음 인스턴스를 생성시 초기화되지 않음
    - 처음 접근할때 초기화가 시작됨