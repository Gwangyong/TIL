# 2025.06.02(월) - Closure.. 난 너가 밉다..
> **Status**: 🎯 **블로그 발행**<br>**Blog**: [Closure.. 난 너가 밉다..](https://jud00.tistory.com/entry/0602-%EC%9B%94-Closure-%EB%82%9C-%EB%84%88%EA%B0%80-%EB%B0%89%EB%8B%A4)

- 팀원들과 강의보다가 Closure가 나옴. 다같이 너무 햇갈리고 확실하게 이해못한 개념.
- 미룰까 하다가 그냥 지금 하는게 바로 이제 시작하는 과제를 하기 도움될거같아 공부 시작

## 클로저(Closure)

- Swift에서 클로저는 코드 블럭을 **변수처럼 저장하고 사용**할 수 있는 기능이다.
- 함수와 유사하게 동작하지만 이름이 없고, 변수에 저장하거나 다른 함수의 파라미터로 넘길 수 있다.
- 클로저는 **참조 타입(Reference Type)으로, Heap에 저장**된다.

> 클로저의 표현식
> 

```swift
{ (매개변수) -> 반환 타입 in
	실행 코드
}
```

`in` 키워드 앞은 입력값과 출력값 정의, 뒤는 실행될 코드다. in을 기준으로 나뉜다는걸 기억하면 쉽다.

> 간단 예제
> 

```swift
let greeting = { (name: String) -> String in
    return "Hello, \(name)!"
}

print(greeting("Mori")) // Hello, Mori!
```

> 축약 형태 (매개변수 없는)
> 

```swift
let greeting = {
	print("Hello, World!")
}

greeting() // Hello, World!
```

이처럼 클로저는 `let` 또는 `var`로 선언한 변수에 담아서 필요할 때 실행할 수 있다.

> 클로저 축약 문법
> 

```swift
// 1. 전체 문법 
let add = { (a: Int, b: Int) -> Int in return a + b }

// 2. 타입 추론
let add = { a, b in return a + b }

// 3. return 생략
let add = { a, b in a + b }

// 4. 축약 인자 이름 ($0, $1, ...)
let add = { $0 + $1 }
출처: https://jud00.tistory.com/entry/0516금-iOS-사전캠프 [MoriOS:티스토리]
```

## 후행 클로저

후행 클로저(Trailing Closure)는 **함수의 마지막 매개변수가 클로저**일 경우, 해당 클로저를 **괄호 바깥으로 빼서** 더 간결하게 작성할 수 있도록 하는 문법이다.

클로저의 본문이 길어지면 가독성이 떨어지기 때문에, 후행 클로저를 사용하여 **코드를 더 간결하고 읽기 쉽게** 할 수 있다.

특히 UIKit의 애니메이션이나, SwiftUI의 뷰 선언 등에서 자주 사용된다.

```swift
// 일반 클로저 전달 방식
함수명(파라미터: { 클로저 })

// 후행 클로저 방식
함수명 { 클로저 }
```

위의 예시처럼, 마지막 파라미터가 클로저일 때 코드를 더 간결하게 만들기 위해 후행 클로저를 사용한다.

> 아래처럼 마지막 파라미터가 클로저가 아니라면 사용할 수 없다.
> 

```swift
func test(closure: () -> Void, b: Int) { }
// ❌ 마지막이 클로저가 아니라서 후행 클로저 사용 불가
```

> UIKit 후행 클로저 예시
> 

```swift
// UIKit예시
UIView.animate(withDuration: 0.3, animations: {
  print("애니메이션 시작")
})

// 후행 클로저 방식
UIView.animate(withDuration: 0.3) {
	print("애니메이션 시작")
}
```

> SwiftUI 후행 클로저 예시
> 

```swift
// SwiftUI 예시
Button(action: {
	print("버튼 눌림")
}) {
    Text("Click!")
}

// 후행 클로저 방식
Button {
	print("버튼 눌림")
} label: {
	Text("Click!")
}
```

## escaping vs non-escaping

`@escaping`은 “탈출하다”는 뜻으로, Swift에서 클로저는 기본적으로 `non-escaping`이다.

즉, 클로저는 함수 **내부에서 실행되며**, 함수가 종료되면 **더 이상 사용되지 않는 것이 기본 동작**이다.

하지만 클로저를 외부에 저장하거나, 나중에 실행하려는 경우에는 **함수가 끝난 뒤에도 클로저가 실행될 수 있어야 하기 때문에**, `@escaping` 키워드를 명시해야 한다.

> 오류 발생 예시
> 

```swift
import UIKit
func esacpingClosure(closure: () -> Void) {
	DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
		closure()
	}
}
```

위의 예시는 함수가 끝나고 1초가 지난 후에 closure를 호출하기 때문에 오류가 발생한다.

> `@escaping` 사용 예시
> 

```swift
import UIKit
func esacpingClosure(closure: @escaping () -> Void) {

    // 1초뒤에 코드블록을 실행하는 코드
    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
        closure()
    }
}

esacpingClosure {
    print("클로저 실행")
}
```

위처럼 함수가 종료된 이후에도 클로저를 실행할 수 있도록 하기위해 `@escaping`을 사용한다.

### **언제 @escaping이 필요한가?**

---

- **비동기 처리 시 (async)**
    
    → 예: DispatchQueue.main.async, 네트워크 요청 등
    
- **클로저를 함수 외부에 저장할 때**
    
    → 예: 클로저를 배열에 저장하거나, 클래스의 속성으로 저장할 경우
    
- **Completion Handler로 사용할 때**
    
    → 예: 네트워크 응답 등 비동기 작업이 완료된 후 실행되는 클로저
    

## 캡처(Capture)

클로저는 자신이 선언된 시점에 주변 변수나 상수를 기억하고, 나중에 그 값을 사용할 수 있다. 이걸 **클로저 캡처** 라고 부른다.

```swift
var number = 10

let printNumber = {
	print(number)
}

number = 20
printNumber() // 20
```

**🧠 메모리 관점에서 잠깐 보자면?**

- Int, Struct, Array 등은 값 타입이며, 기본적으로 Stack 메모리에 저장된다.
- 하지만 클로저가 var같은 외부 변수를 캡처하면, Swift는 해당 변수를 Heap에 박싱(boxing)하고
- 원본 코드와 클로저가 같은 저장 공간을 공유하도록 만든다.
- 그래서 값 타입임에도 불구하고, 변수의 변경이 클로저에도 반영되서 최신 값이 출력쵠다.

**✅ 정리하자면**

Int는 값 타입이지만, 클로저 내부에서는 참조 방식처럼 동작하기 때문에 최신 값이 사용된다!

## 캡처 리스트(Capture List)

클로저는 외부 변수를 사용할 때 기본적으로 **강한(strong)참조로 캡처**한다. 이로 인해 **메모리 누수**나, **예상하지 않은 값 변경** 문제가 발생할 수 있다.

이러한 문제를 해결하기 위해서 캡처 리스트를 사용하여, **메모리 관리 방식(weak, unowned)**을 지정할 수 있다.

> 캡처 리스트 문법
> 

```swift
let closure1 = { [캡처방식 변수명] in ... }
let closure2 = { [변수명] in ... }
```

- 캡처 리스트는 [캡처방식 변수명] 또는 [변수명] 형태로 작성된다.

> 예시
> 

```swift
{ [weak self] in ... }
{ [unowned user] in ... }
{ [user] in ... } 
```

- `weak`: 참조 카운트를 올리지 않으며, 값이 해제되면 nil이 된다.
- `unowned`: 참조 카운트를 올리지 않지만, 값이 해제된 뒤 접근하면 크래시가 발생한다.

### 참조 타입 (Reference Type)캡처

---

위에서 말했듯, 클로저가 클래스 인스턴스와 같은 참조 타입을 클로저가 캡처할 경우, **순환 참조로 인한 메모리 누수**를 방지하기 위해 **메모리 관리 방식(weak/unowned)**을 고려해야한다.

```swift
class Dog {
	var age = 1
}

var dog = Dog()

let closure = { [weak dog] in
	print(dog?.age ?? -1)
}
```

### 값 타입 (Value Type)캡처

---

클로저는 Int, Struct 등의 값 타입도 **복사하지 않고 참조처럼 캡처**하려고 한다. 즉, 클로저 안에서는 **원본의 변화를 따라가며 최신 값을 사용**하게 된다.

그렇기에 값 타입에서는 캡처 시점의 값을 확정적으로 쓰고 싶을 때 캡처 리스트가 필요하다.

> 참조처럼 캡처되는 예시
> 

```swift
struct Person {
	var name: String
}

var p = Person(name: "John")

let closure = {
	print(p.name)
}

p.name = "Changed"

closure() // "Changed"
```

→ 클로저는 외부 변수 `p`를 참조처럼 기억하고 있어서 변경된 최신의 값을 출력한다.

> 복사해서 사용하려면?
> 

```swift
let closure = { [p] in
    print(p.name)
}

p.name = "Changed"
closure() // "John"
```

→ 캡처 리스트로 [p]를 명시하면, 그 시점의 값이 복사되어 클로저 안에 담을 수 있게 된다.

## **🧾 정리 요약**

- 클로저는 외부 변수를 기본적으로 strong 참조로 캡처함
- 참조 타입은 메모리 누수 방지를 위해 [weak 변수], [unowned 변수] 사용
- 값 타입도 참조처럼 캡처되므로, 복사된 값을 쓰고 싶으면 [변수]로 명시

## Closure 전체 정리

- 클로저는 이름 없는 함수처럼 사용된다.
- 주변 변수나 상수를 기억하고 나중에 사용할 수 있다. 이를 **클로저 캡처**라고 한다.
- 비동기나 함수 외부에서 클로저를 사용할 경우 `@escaping` 키워드가 필요하다.
- 메모리 누수를 방지하려면 캡처 리스트로 참조 방식(weak, unowned)을 지정해야 한다.
- 값 타입도 기본적으로는 참조처럼 캡처되므로. 값을 복사하고 싶으면 [변수] 형식으로 사용할 수 있다.